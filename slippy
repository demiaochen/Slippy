#!/usr/bin/env python3

"""
UNSW COMP2041 22T2 Assignment 2 Slippy
    https://cgi.cse.unsw.edu.au/~cs2041/22T2/assignments/ass2/index.html

Written by: Demiao Chen (z5289988)
░░░░░░░░░░░░░░░░░█▀▄░█▀▀░█▀▄░█▀▀░█░█░░░█▀▀░█░█░█▀▀░█▀█░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░█░█░█▀▀░█▀▄░█▀▀░█▀▄░░░█░░░█▀█░█▀▀░█░█░░░░░░░░░░░░░░░░░░
░░░░░░░░░░░░░░░░░▀▀░░▀▀▀░▀░▀░▀▀▀░▀░▀░░░▀▀▀░▀░▀░▀▀▀░▀░▀░░░░░░░░░░░░░░░░░░
Date: 6-Aug-2022

    Slippy stands for [S]ed [L]anguage [I]nterpreter in [P]ure [PY]thon.
    A subset of the important Unix/Linux tool Sed.
    Sed is a very complex program that has many commands.
    Sed: https://www.gnu.org/software/sed/manual/sed.html
    Slippy is a POSIX-compatible subset of sed with extended 
    regular expressions (EREs).

    
   ▄████████  ▄█        ▄█     ▄███████▄    ▄███████▄ ▄██   ▄   
  ███    ███ ███       ███    ███    ███   ███    ███ ███   ██▄ 
  ███    █▀  ███       ███▌   ███    ███   ███    ███ ███▄▄▄███ 
  ███        ███       ███▌   ███    ███   ███    ███ ▀▀▀▀▀▀███ 
▀███████████ ███       ███▌ ▀█████████▀  ▀█████████▀  ▄██   ███ 
         ███ ███       ███    ███          ███        ███   ███ 
   ▄█    ███ ███▌    ▄ ███    ███          ███        ███   ███ 
 ▄████████▀  █████▄▄██ █▀    ▄████▀       ▄████▀       ▀█████▀  
             ▀                                                  

                                ASCII arts generated from: textkool.com
"""

import os
import re
import shutil  # cp
import sys
import argparse
from argparse import ArgumentParser

# Slippy command will be one of 'q', 'p', 'd', or 's'
SLIPPY_COMMAND = ["q", "p", "d", "s"]
TEMP_FILE_W = ".slippy_temp_w"
TEMP_FILE_R = ".slippy_temp_r"
FILE_BUFFER_LIMIT = 8100000  # 1MB read limit from stdin

# signals
DELETE = int(1)
QUIT = int(2)

################################ COMMANDs ####################################


def sed_quit(pattern, args):
    if type(pattern) == int:
        for _ in range(0, int(pattern)):
            line = sys.stdin.readline()
            if line == "":
                break
            if not args.n:
                print(line, end="")

    else:
        for line in sys.stdin.readlines():
            if not args.n:
                print(line, end="")
            if re.search(pattern, line):
                break


def sed_print(pattern, args):
    if pattern == " ":
        for line in sys.stdin.readlines():
            if not args.n:
                print(line, end="")
            print(line, end="")
    elif type(pattern) == int:
        for idx, line in enumerate(sys.stdin.readlines()):
            if not args.n:
                print(line, end="")
            # print target line
            if idx + 1 == int(pattern):
                print(line, end="")
    else:
        for line in sys.stdin.readlines():
            if not args.n:
                print(line, end="")
            if re.search(pattern, line):
                print(line, end="")


def sed_delete(pattern, args):
    if pattern == " ":
        pass
    elif type(pattern) == int:
        for idx, line in enumerate(sys.stdin.readlines()):
            if idx + 1 == int(pattern):
                continue
            if not args.n:
                print(line, end="")
    else:
        for line in sys.stdin.readlines():
            if re.search(pattern, line):
                continue
            if not args.n:
                print(line, end="")


def sed_search(position, pattern, target, replacement, is_global, args):
    if position == -1:
        for idx, line in enumerate(sys.stdin.readlines()):
            # find pattern match, replace it
            if re.search(pattern, line):
                count = 1
                if is_global:
                    count = 0
                line = re.sub(target, replacement, line, count=count)
                print(line, end="")
                continue
            if not args.n:
                print(line, end="")
    else:
        for idx, line in enumerate(sys.stdin.readlines()):
            # only replace position line
            if idx + 1 == position:
                # find pattern match, replace it
                if re.search(pattern, line):
                    count = 1
                    if is_global:
                        count = 0
                    line = re.sub(target, replacement, line, count=count)
                    print(line, end="")
                    continue
            if not args.n:
                print(line, end="")


# options is a dictionary that maps command to function
options = {"q": sed_quit, "p": sed_print, "d": sed_delete, "s": sed_search}


def slippy_quit(sed_command, line, position, args):
    if not args.n:
        print(line, end="")

    if sed_command["pattern"] == " ":
        return QUIT
    elif type(sed_command["pattern"]) == int:
        if int(sed_command["pattern"]) == position:
            return QUIT
    else:
        if re.search(sed_command["pattern"], line):
            return QUIT
    return 0


def slippy_delete(sed_command, line, position, args):
    if sed_command["pattern"] == " ":
        return DELETE
    elif type(sed_command["pattern"]) == int:
        if int(sed_command["pattern"]) == position:
            return DELETE
    else:
        if re.search(sed_command["pattern"], line):
            return DELETE
    if not args.n:
        print(line, end="")
    return 0


def slippy_print(sed_command, line, position, args):
    if not args.n:
        print(line, end="")

    if sed_command["pattern"] == " ":
        print(line, end="")
    elif type(sed_command["pattern"]) == int:
        if int(sed_command["pattern"]) == position:
            print(line, end="")
    else:
        if re.search(sed_command["pattern"], line):
            print(line, end="")
    return 0


def slippy_search(sed_command, line, position, args):
    count = 1
    if sed_command["is_global"]:
        count = 0

    if sed_command["position"] == position or sed_command["position"] == -1:
        if re.search(sed_command["pattern"], line):
            print(
                re.sub(
                    sed_command["target"], sed_command["replacement"], line, count=count
                ),
                end="",
            )
        else:
            if not args.n:
                print(line, end="")
    else:
        if not args.n:
            print(line, end="")
    return 0


perform_command = {
    "q": slippy_quit,
    "p": slippy_print,
    "d": slippy_delete,
    "s": slippy_search,
}


def perform(sed_command_list, args):
    idx = 0
    while True:
        line = sys.stdin.readline()
        # returns an empty string, the end of the file has been reached
        if line == "":
            break
        for sed_command in sed_command_list:
            signal = perform_command[sed_command["command_type"]](
                sed_command, line, idx + 1, args
            )
            if signal == DELETE:
                break
            if signal == QUIT:
                return
        idx += 1


#################################### HELPERs ######################################


def get_splitter(string):
    if string[0] in ["s"]:
        splitter = string[1]
        if splitter == string[-1]:
            return splitter
    for ch in string:
        if ch in ["/", "|", "#"]:
            return ch
    return None


def invalid_command():
    # if os.isfile(TEMP_FILE_W):
    #     os.remove(TEMP_FILE_W)
    # if os.isfile(TEMP_FILE_R):
    #     os.remove(TEMP_FILE_R)
    print(f"{sys.argv[0]}: command line: invalid command")
    sys.exit(1)


# return regex pattern
def get_pattern(commands, position):
    try:
        return re.compile(commands[position])
    except:
        print(f"{sys.argv[0]}: command line: invalid command")
        sys.exit(1)


# return string
def get_sed_command(commands, position):
    try:
        sed_command = commands[position]
        if sed_command not in SLIPPY_COMMAND:
            invalid_command()
        return sed_command
    except:
        invalid_command()


################################## MAIN ######################################


def main():
    regex_mode = True
    # command line arguments analysis
    parser = ArgumentParser(
        usage=f"{sys.argv[0]} [-i] [-n] [-f <script-file> | <sed-command>] [<files>...]",
        exit_on_error=False,
    )
    parser.add_argument("-i", action="store_true")
    parser.add_argument("-n", action="store_true")
    # parser.add_argument("-f script", action="store_true")
    parser.add_argument("command")
    parser.add_argument("files", action="store_true")

    if len(sys.argv) == 1:
        parser.print_usage()
        sys.exit(1)

    try:
        args, unknown = parser.parse_known_args()
        if unknown != []:
            print(f"{sys.argv[0]}: error")
            sys.exit(1)
    except argparse.ArgumentError as e:
        print(e)

    # change stdout to
    # sys.stdout = open(TEMP_FILE_W, 'w')

    # commands separated by ; and newline
    args_command_list = re.split(";|\n", args.command)
    # print(args_command_list)
    sed_command_list = []
    """    
    command_args = {

        "position": int or regex,  # -1 for all

        "position_start": int or regex,
        "position_end":   int or regex,
        "in_position": bool,   # toggled by start and end

        "command_type": str,
        "is_global": bool,
        "pattern": regex,
        "target": regex,
        "replacement": regex,
    }
    """

    for args_command in args_command_list:

        # -1 means apply to all lines
        position = -1

        position_start = 0
        position_end = 0

        is_global = (False,)
        pattern = ""
        target = ""
        replacement = ""

        splitter = get_splitter(args_command)

        # Regex mode
        if splitter != None:  # sed splitter
            commands = args_command.split(splitter)
            is_global = False
            # -1 means apply to all lines
            position = -1

            # /pattern/command  eg /.3/q
            # /pattern/command/target/repl/q  eg '/1.1/s/1/-/g'
            if commands[0] == "":
                pattern = get_pattern(commands, 1)
                sed_command = get_sed_command(commands, 2)
                # '/1.1/s/1/-/g'
                if sed_command == "s":
                    try:
                        target = commands[3]
                        replacement = commands[4]
                    except:
                        invalid_command()
                    try:
                        if commands[5] == "g":
                            is_global = True
                    except:
                        pass

            # s/pattern/replacement/g
            # '5s/5/9/g'
            # ['5s', '5', '9', 'g']
            else:
                # separate number and command
                head = re.split("(\d+)", commands[0])
                if len(head) == 1:  # s/5/9/g' ['s']
                    sed_command = head[0]
                elif len(head) == 3:  #'5s/5/9/g' ['', '5', 's']
                    try:
                        position = int(head[1])
                    except:
                        invalid_command()
                    sed_command = get_sed_command(head, 2)
                else:
                    invalid_command()

                try:
                    if commands[3] == "g":
                        is_global = True
                except:
                    pass

                if sed_command == "s":
                    try:
                        pattern = get_pattern(commands, 1)
                        target = commands[1]
                        replacement = commands[2]
                    except:
                        invalid_command()

        # Number Mode
        else:
            sed_command = args_command[-1]
            if len(args_command) == 1:
                pattern = " "
            else:
                try:
                    pattern = int(args_command[:-1])
                except:
                    invalid_command()
                # handled by flag error
                # if pattern < 0:
                #     args.print_usage()
                #     sys.exit(1)
            if sed_command not in ["q", "p", "d"]:
                invalid_command()

        if sed_command not in SLIPPY_COMMAND:
            invalid_command()

        command_args = {
            "command_type": sed_command,
            "position": position,
            "position_start": position_start,
            "position_end": position_end,
            "in_position": False,
            "is_global": is_global,
            "pattern": pattern,
            "target": target,
            "replacement": replacement,
        }

        sed_command_list.append(command_args)

    perform(sed_command_list, args)


if __name__ == "__main__":
    main()
